/*In usb the controller needs to gather small pieces of data scattered across the driver stack and send them as one continuous stream to the device. Link pointer status byte buffer pointer control bits.
A usb td is a fixed size block that contains : a link pointer the physical address of the next td in chain, status byte: an integer that the hardware toggles when the transfer is active or complete,
buffer pointer: physical address of the raw data, control bits: metadata telling the hardware if this is a read/write. 
A deeper look at the function fgets

char *fgets(char *s, int n, FILE *fp) {
    register char *p = s;
    register int c;
    if (n <= 0) return NULL;
    // Loop until we've read n-1 characters
    while (--n > 0) {
        // Get character from the internal stream buffer
        c = getc(fp); 
      
        if (c == EOF) {
            if (p == s) return NULL; // Nothing read
            break;
        }

        *p++ = c;
        if (c == '\n') break; // Stop at newline
    }

    *p = '\0'; // Always add the null terminator
    return s;
}
the driver needs to replace them from the usb registers to ram, it will use a function copying data from the buffer in usb, the usb TD provides a pointer to the physical address o fthe raw
data. fgets checks the internal bufferif it is empty and if it contains a \n, fgets make a system call to the kernel to pull a large block of data from the disk/NIC into the internal buffer
it then copies the bytes from the internal buffer into your provided buffer. It stops when it hits a null terminator. If you want to read 100 lines fgets might only call read() once to get 
4096 bytes. It then serves the next 99 lines directly from its internal RAM buffer without asking the OS for help again. fgets is for text, if your network packet contains binary data like 
an image or a checksum that happens to include the byte 0x0A fgets will stop prematurely thinking it found a line. You should use memcpy or direct DMA transfers. 
void *memcpy(void *dest, const void *src, size_t n) {
    unsigned char *d = (unsigned char *)dest;
    const unsigned char *s = (const unsigned char *)src;

    // Loop until all n bytes are moved
    while (n--) {
        *d = *s; // Load from source, store to destination
        d++; // Increment destination pointer
        s++; // Increment source pointer
    }

    return dest;
}

; void *memcpy(void *dest, const void *src, size_t n)
; Arguments (32-bit): [esp+4]=dest, [esp+8]=src, [esp+12]=n

memcpy:
    push edi
    push esi
    
    mov edi, [esp+12] ; Load Destination pointer
    mov esi, [esp+16] ; Load Source pointer
    mov ecx, [esp+20] ; Load Number of bytes (n)

    ; Optimization: Move as many 4-byte chunks (DWORDS) as possible
    mov edx, ecx ; Save original count
    shr ecx, 2 ; Divide n by 4 (ecx = number of dwords)
    rep movsd ; Move 4 bytes at a time, incrementing esi/edi

    ; Clean up: Move the remaining 1-3 bytes (the "tail")
    mov ecx, edx
    and ecx, 3 ; ecx = n % 4
    rep movsb ; Move the last few bytes

    pop esi
    pop edi
    ret

FILE is an opaque structure meaning its internal fields are hidden from you, but they contain the metadata required to handle the stream. If you were to peak inside the structure you would find a file descriptor
the internal buffer pointer, the current position pointer, bytes remaining, flags. 
*/

typedef struct { 
  TD *next;
  int toggle; // an integer that the hardware toggles when the transfer is active or complete
  char *buffer;//physical address of the raw data, the payload
  int status;//read or write
} TD; 
int td_numbers[9];
int count=0;
while (count<9) {
  n=TD1->buffer;
  memcpy(void *dest, void *src, size_t n)
  count++;
  TD1->toggle=1;
  TD=TD1->next;
} 
mov ead, [esi] ; we assume that everything happens in RAM
mov [edi], ead ;
add esi, 4 ;
add edi, 4;
dec ecx;
jnz loop_start;





























