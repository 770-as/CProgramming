#include <iostream>
#include <vector>
#include <stdexcept>

// 1. Define the required constant BEFORE the function that uses it
// We use 'constexpr' so it can be used in constant expressions.
constexpr size_t MAX_SIZE = 5; 

using namespace std;

/**
 * @brief Creates a vector, validating its size against MAX_SIZE.
 * This function can be run at compile time (constexpr) or runtime.
 * @param size The desired size of the vector.
 * @return A std::vector initialized with 'size' elements.
 */
constexpr vector<int> create_validated_vector(size_t size) {
    // The compiler now knows what MAX_SIZE is. 
    if (size > MAX_SIZE) { 
        // Throwing here causes a compile-time error if called with a constant size > 5
        // or a runtime exception if called with a variable size > 5.
        throw runtime_error("Requested vector size exceeds constexpr MAX_SIZE.");
    }
    
    // Create and fill the vector
    vector<int> vec(size); 
    for (size_t i = 0; i < size; ++i) {
        vec[i] = static_cast<int>(i) * 10;
    }
    return vec;
}

int main() {
    cout << "C++20 Constexpr Vector Validation Demo (Max Size: " << MAX_SIZE << ")\n" << endl;

    // --- 1. Compile-Time Success ---
    // The compiler runs create_validated_vector(3) at compile time.
    constexpr auto compile_time_vec = create_validated_vector(3);
    
    // This static_assert proves compile-time execution.
    static_assert(compile_time_vec.size() == 3, "Size check failed.");

    cout << "1. Compile-Time Success (Vector size: " << compile_time_vec.size() << ")" << endl;
    cout << "   Element at index 2: " << compile_time_vec[2] << " (2 * 10 = 20)\n" << endl;


    // --- 2. Runtime Exception ---
    int runtime_size_fail = 7;
    cout << "2. Runtime Exception Case (Size: " << runtime_size_fail << ")" << endl;
    try {
        // This call executes the 'throw' at RUNTIME
        create_validated_vector(runtime_size_fail); 
    } catch (const runtime_error& e) {
        cout << "   Caught exception: " << e.what() << endl;
    }

    return 0;
}












/*
The Qualifier (Since C++11, improved in C++14/17/20). This is the most special part. It means the function can be evaluated at 
Compile Time if all the arguments passed to it (size) are constant expressions. If the arguments are variables, it runs normally 
at Run Time. This is the key to achieving performance and compile-time validation.
The core purpose of constexpr is to move computation from the slow, unpredictable runtime environment to the fast, static 
compile-time environment.

Runtime Cost is Zero: If a constexpr function is successfully evaluated at compile time, the final result is calculated once and
baked directly into the executable as a constant value. At runtime, the program doesn't execute the function's logic, a loop, or
an if statement—it just uses the pre-calculated number. This is the ultimate performance optimization.
Example: Calculating the 500 
th
Fibonacci number using a constexpr function takes a millisecond during compilation. If you ran that same function at runtime, 
it would take CPU cycles every time the program executes.

Better Optimization: The compiler can perform aggressive optimizations on constant values that it cannot perform on runtime 
variables.

2. Reliability: Compile-Time Validation
constexpr is a powerful tool for catching errors much earlier in the development process.

Static Assertions: The static_assert keyword requires a boolean constant expression. By using a constexpr function inside a 
static_assert, you can check the logical integrity of your code during compilation. If the check fails, the compiler immediately
halts with an error, preventing you from ever shipping a broken program.

Example: Checking that a configuration value generated by a constexpr calculation is within an acceptable range:

C++

static_assert(calculate_checksum(data) == EXPECTED_VALUE, "Data corruption detected at compile time!");
Preventing Errors: In the case of create_validated_vector, if you attempt to initialize a constexpr variable with a size that is

too large (like size 10 when MAX_SIZE$ is $5$), the throw` inside the function will cause the entire constant expression 
evaluation to fail, resulting in a compilation error. This is far better than a program crashing later at runtime.

3. Flexibility: The "Two-in-One" Function
One of the cleverest parts of constexpr is that it creates a single function that can serve two roles:

Scenario	Code Example	Execution Time
Compile Time	constexpr int result = func(5);	Compiler executes the body.
Runtime	int variable = getUserInput(); … int result = func(variable);	CPU executes the body.

Exporter vers Sheets
No Code Duplication: You do not have to write a separate template meta-programming solution for compile-time constants and a 
regular function for runtime variables. The compiler handles the dual behavior automatically, making your codebase smaller and 
easier to maintain.

Standard Library Usage (C++20): The ability to use containers like std::vector and std::string in a constexpr context 
(since C++20) means you can write complex data processing code (like parsing a configuration file or generating a hash map) in 
a normal, readable C++ function, and yet have it executed entirely by the compiler. This is a massive simplification of complex 
compile-time programming.
*/